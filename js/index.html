<html>
<head>

<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'unsafe-inline' sfxr.me; connect-src localhost:* ws://127.0.0.1:*;">
<!--
# more info on how CSP works
https://content-security-policy.com/
https://stackoverflow.com/questions/30280370/how-does-content-security-policy-csp-work
-->
</head>

<body> 

<script src="https://sfxr.me/riffwave.js"></script>
<script src="https://sfxr.me/sfxr.js"></script>    

<canvas width="500" height="500" id="board"></canvas>

<script> 

    // matrix of active points on the grid
    const mm_points = [
        [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], 
        [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0], 
        [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0], 
        [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], 
        [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0], 
        [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], 
        [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], 
        [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], 
        [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], 
        [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], 
        [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], 
        [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], 
        [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], 
        [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], 
        [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0], 
        [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], 
        [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0], 
        [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0], 
        [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0] 
        ];

    const mm_points_rows = 19 // mm_points.length;
    const mm_points_cols = 11 // mm_points[0].length;

    // helper function to extract array columns from matrix
    function getCol(matrix, n_col){
        return matrix.map(v => v[n_col]);
    }

    // helper function to know how many triangles we should draw
    function numTriangles(array) {
        let counter = 0;
        for (item of array.flat()) {
            if (item) {
                counter++;
            }
        }
        return counter - 1;
    }

    // initialize canvas
    var canvas = document.getElementById('board'); 
    var ctx = canvas.getContext('2d', { alpha: true }); 

    // Audio effects
    const sound = {
                    "p_hpf_freq": 0.104,
                    "p_duty": 0.457,
                    "p_pha_offset": 0.142,
                    "p_env_sustain": 0.047,
                    "wave_type": 2,
                    "preset": "click",
                    "p_lpf_freq": 1,
                    "p_env_decay": 0.467,
                    "sample_size": 8,
                    "p_arp_speed": 0,
                    "p_vib_speed": 0,
                    "p_freq_limit": 0,
                    "p_vib_strength": 1,
                    "p_pha_ramp": 0.526,
                    "p_lpf_ramp": 0,
                    "p_lpf_resonance": 0.633,
                    "name": null,
                    "p_base_freq": 0.348,
                    "p_hpf_ramp": 0,
                    "ctime": 1674601289935,
                    "p_repeat_speed": 0,
                    "p_freq_ramp": -0.47,
                    "sound_vol": 0.25,
                    "p_arp_mod": -1,
                    "p_env_punch": 0.083,
                    "oldParams": true,
                    "p_env_attack": 0,
                    "p_freq_dramp": -1,
                    "sample_rate": 22050,
                    "p_duty_ramp": 0.537,
                    "mtime": 1674604666633
                    }


    // NOTE:
    // pre-draw board and store it for later 


    /* SAVE FOR LATER
    // TAKEN FROM https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas
    // Get the DPR and size of the canvas
    const dpr = window.devicePixelRatio;
    const rect = canvas.getBoundingClientRect();

    // Set the "actual" size of the canvas
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;

    // Scale the context to ensure correct drawing operations
    ctx.scale(dpr, dpr);

    // Set the "drawn" size of the canvas
    canvas.style.width = `${rect.width}px`;
    canvas.style.height = `${rect.height}px`;
    */


    // initialize array for markers and rings
    let shapes = [];
    let capture_zones = [];

    // these values are used in shapes objects, status, and check conditions within functions - better centralize their definition
    const ring_id = "R";
    const marker_id = "M";
    const player_black_id = "B";
    const player_white_id = "W";

    // add random rings in array of shapes
    shapes.push({path:{}, x:50, y:120, m_row: 0, m_col: 0, type: ring_id, player: player_black_id, active:false});
    shapes.push({path:{}, x:50, y:160, m_row: 0, m_col: 0, type: ring_id, player: player_white_id, active:false});

    // specify dimensions for the triangles in the grid
    // for now outside, so they can be set depending on possible canvas size
    let S = 40;
    let H = Math.round(S * Math.sqrt(3)/2);
    
    // board and initial state drawn for the first time
    // this function is then called by the single events when they change the state
    refresh_draw_state();

    function refresh_draw_state(){
        ctx.save();
        
        // clears everything and re-draws board
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw board
        draw_board();

        // keep capture zones up
        setup_capture_zones()

        // Re-draw latest state
        for(let i=0; i<shapes.length; i++){
            draw_shape(shapes[i]);};

        ctx.restore();

    }
  
        function draw_board(){

        ctx.save();
            /* RECIPE
            - get to first starting point for column
            - draw triangle, if first extra bit
                -- only if next colum is bigger
            - translate down
            - draw triangle
            - repeat
            - drawn triangle, if last extra bit 
                -- only if next colum is bigger
            - column before last, 2 vertical strokes
            - last column, 3 vertical strokes

            */

            // drawing settings
            ctx.lineJoin = "round";
            ctx.strokeStyle = '#2C68DC';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.65;


            for (let k = 1; k <= mm_points_cols-1; k++) {
                
                // number of triangles we're expected to draw for each column
                triangle_ToDraw = numTriangles(getCol(mm_points, k-1));
                triangle_Drew = 0;

                // move right for each new column
                ctx.translate(H*k,H);

                // going down the individual columns
                for (let j = 1; j <= mm_points_rows; j++) {
                    
                    let point = mm_points[j-1][k-1];

                    // manual handling of last column 
                    if (k == mm_points_cols-1 && (j == 4 || j > 13) ){point = 0;}
                    

                    // if point is not active just translate down
                    if (point == 0) {
                        ctx.translate(0,S/2);
                    
                    // DRAWING LOOP!
                    // draw triangle but only if we're not done drawing them all
                    } else if (point == 1 && triangle_Drew < triangle_ToDraw) {
                        ctx.beginPath();
                        ctx.moveTo(0,0); // starting point for drawing
                        ctx.lineTo(0,S); // first point down
                        ctx.lineTo(H,S/2); // mid-point to the right
                        ctx.closePath(); // close shape
                        ctx.stroke();
                        triangle_Drew ++;

                        
                        // check if the next column has more triangles
                        let mustDraw_stick = triangle_ToDraw < numTriangles(getCol(mm_points, k));
                        
                        // we do this for all columns except last
                        if (mustDraw_stick && k < mm_points_cols) {

                            // first triangle bridging up
                            if (triangle_Drew == 1){
                                ctx.beginPath();
                                ctx.moveTo(0,0); 
                                ctx.lineTo(H,-S/2); 
                                //ctx.strokeStyle = "#FA5537";
                                ctx.stroke();
                                
                                //ctx.strokeStyle = colT;
                            }

                            // last triangle bridging down
                            if (triangle_Drew == triangle_ToDraw){
                                ctx.beginPath();
                                ctx.moveTo(0,S);
                                ctx.lineTo(H,S+S/2);
                                //ctx.strokeStyle = "#32CBFF";
                                ctx.stroke();
                                
                                //ctx.strokeStyle = colT; // reset color
                            }

                        }

                        // draw vertical strokes 
                        // last column, last triangle done (+2 hack as we disqualify points above)
                        if (k == mm_points_cols-1 && triangle_ToDraw == triangle_Drew + 2) {
                            // stroke down
                            ctx.beginPath();
                            ctx.moveTo(0,S); 
                            ctx.lineTo(0,2*S); 
                            //ctx.strokeStyle = "#C21313";
                            ctx.stroke();
                            
                            // stroke up
                            ctx.beginPath();
                            ctx.moveTo(0,-3*S); 
                            ctx.lineTo(0,-4*S); 
                            //ctx.strokeStyle = "#E79B33";
                            ctx.stroke();
                            
                            // stroke up
                            ctx.beginPath();
                            ctx.moveTo(H,-S*2-S/2); 
                            ctx.lineTo(H,S/2); 
                            //ctx.strokeStyle = "#C21313";
                            ctx.stroke();
                            
                            //ctx.strokeStyle = colT; // reset color 
                        }
                        
                    // move down (considering last active point when drawing)
                    ctx.translate(0,S/2);

                
                    } // stop going down the column and drawing if you're done 
                    else if ( triangle_Drew == triangle_ToDraw) {
                        break;
                    }
                }
                // reset canvas transformations before moving to next column
                ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
                
            ctx.restore();
        }

        function setup_capture_zones(){
            ctx.save();

            ctx.globalAlpha = 0; // set transparency for circles
            ctx.strokeStyle = "#666";
            ctx.lineWidth = 0.5;
            
            // create circles for listening to click events on all intersections
            for (let j = 1; j <= mm_points_rows; j++) {
                for (let k = 1; k <= mm_points_cols; k++) {

                    // using indexes 1:N for accessing the matrix
                    // these indexes then become row/col coordinates for rings & markers as inherited post-snapping
                    let point = mm_points[j-1][k-1];

                    if (point == 1) {

                        // ACTIVE POINTS COORDINATES
                        // we move by x = (H * k) & y = H for each new column
                        // we also move by y = S/2 in between each row (active and non-active points)
                        
                        let apoint_x = H * k;
                        let apoint_y = H + S/2 * (j-1); // S/2 shift kicks in only from 2nd row
                        
                        // draw circles in each intersection point and add them to an array
                        let capture_path = new Path2D()
                        capture_path.arc(apoint_x, apoint_y, S*0.35, 0, 2*Math.PI);
                        ctx.stroke(capture_path);

                        // update path shape definition
                        capture_zones.push({path: capture_path, x:apoint_x, y:apoint_y, m_row:j, m_col:k});
                        

                    }
                }
            }

            ctx.restore();
        }

        function draw_shape(s){
        // expects to receive an input elements from the shapes array
        ctx.save();

        if (s.type == ring_id ){

            let inner = S*0.42;
            let circle_lineWidth = inner/3;

            if (s.player == player_black_id){ 
                
                ctx.strokeStyle = "#1A1A1A";
                ctx.lineWidth = circle_lineWidth;            
                
                let ring_path = new Path2D()
                ring_path.arc(s.x, s.y, inner, 0, 2*Math.PI);
                ctx.stroke(ring_path);

                // update path shape definition
                s.path = ring_path;
        
            } else if (s.player == player_white_id){

                

                //inner white ~ light gray
                ctx.strokeStyle = "#F6F7F6";
                ctx.lineWidth = circle_lineWidth*0.95;            
                
                let ring_path = new Path2D()
                ring_path.arc(s.x, s.y, inner, 0, 2*Math.PI);
                ctx.stroke(ring_path);

                // outer border
                ctx.strokeStyle = "#000";
                ctx.lineWidth = circle_lineWidth/10; 
                
                let outerB_path = new Path2D()
                outerB_path.arc(s.x, s.y, inner*1.15, 0, 2*Math.PI);
                ctx.stroke(outerB_path);
                
                ring_path.addPath(outerB_path);

                // inner border
                ctx.strokeStyle = "#000";
                ctx.lineWidth = circle_lineWidth/10;  

                let innerB_path = new Path2D()
                innerB_path.arc(s.x, s.y, inner*0.85, 0, 2*Math.PI);
                ctx.stroke(innerB_path);

                ring_path.addPath(outerB_path);

                // update path shape definition
                s.path = ring_path;

            };
        };

        ctx.restore();

    };


    // Empty game state
    let game_state = Array(19*11).fill(""); 

    // from col/row in a matrix to a linear index 
    // Julia expects col-major for building a matrix from an index
    // also, js arrays start at 0, hence the -1 offset
    function reshape_index(row, col) { return (col-1)*19 + row -1; };

    // instatiate event target for changes to the game state
    let game_state_target = new EventTarget()
    
    // listens to ring drops and updates game state
    game_state_target.addEventListener("ring_dropped", 
        function (evt) {

        index = reshape_index(evt.detail.m_row, evt.detail.m_col);
        value = evt.detail.type.concat(evt.detail.player);

        game_state[index] = value;
        console.log(`${value} dropped at ${evt.detail.m_row}:${evt.detail.m_col} -> ${index}`);

    });

    // listens to ring picks and updates game state
    game_state_target.addEventListener("ring_picked", 
        function (evt) {

        index = reshape_index(evt.detail.m_row, evt.detail.m_col);
        value = evt.detail.type.concat(evt.detail.player);

        game_state[index] = "";
        console.log(`${value} picked from ${evt.detail.m_row}:${evt.detail.m_col} at -> ${index}`);

        row = evt.detail.m_row;
        col = evt.detail.m_col;

        allowed_moves = server_allowed_moves(game_state, row, col);

    });

    // If a move is underway, need to drop the ring before doing something else
    function check_active_ring() {
        // if any ring is set to active, returns its index - otherwise "no"
        // returning false/true clashes with returning 0/1 for shape index

        to_return = "no_ring";
        
        for(let i=0; i<shapes.length; i++){
            if (shapes[i].active == true){
                to_return = i;
                break;
            };
        };

        //console.log(to_return);
        return to_return;
    };
    
    // function to return x,y of closest capture zone
    function closest_snap(xp, yp){

        to_return = "no_snap";

        // test which capture zone the mouse is selecting and return its center coordinates
        for(let i=0; i<capture_zones.length; i++){
            if (ctx.isPointInPath(capture_zones[i].path, xp, yp)){
                to_return = {
                            x: capture_zones[i].x, 
                            y: capture_zones[i].y,
                            m_row: capture_zones[i].m_row,
                            m_col: capture_zones[i].m_col
                            }; 
            };
        };

        return to_return;

    };

    // IDEAS
    // use capture zones to highlight allowable moves
    // animate capture zones size/coloring/wave


    // CAPTURE MOUSE EVENTS AND DO SOMETHING
    // https://bencentra.com/code/2014/12/05/html5-canvas-touch-events.html

    let mousePos = { x:0, y:0 };
    let some_var = false;
    canvas.addEventListener("mousedown", 
        function (evt) {
            mousePos = getMousePos(canvas, evt);
            //console.log("down");

            active_ring = check_active_ring();

            // if no ring is already active, then set the selected to active
            if (active_ring === "no_ring"){

                // test which shape the mouse is selecting and set it to active
                for(let i=0; i<shapes.length; i++){
                    
                    // set selected path to active if it's a ring
                    if (ctx.isPointInPath(shapes[i].path, mousePos.x, mousePos.y)){
                        if (shapes[i].type == ring_id){
                            
                            
                            shapes[i].active = true;

                            // create and dispatch event for what the ring being picked up -> game state should change
                            const ringPick_event = new CustomEvent("ring_picked", { detail: shapes[i] });
                            game_state_target.dispatchEvent(ringPick_event);

                            // here I should have a callback that then dispatches an event to the game drawing target
                            
                            // remove the element and put it back at the end of the array, so it's always drawn last => on top
                            // note: splice returns the array of removed elements
                            shapes.push(shapes.splice(i,1)[0]);
                            //console.log(shapes);
                            
                            break; // otherwise it keeps looping and can encounter the same ring twice as we move it to the end
                        
                        };
                    };
                };

            } else {
                // drop in place the currently active ring  
                // the ring must snap to the grid 

                drop_coord = closest_snap(mousePos.x, mousePos.y);

                if (drop_coord !== "no_snap"){

                    // the server should confirm that the coordinates are okay
                    // all of these should be wrapped into functions that take care of single tasks (legality check, update ring values and state, etc)

                    // making the ring inactive again
                    shapes[active_ring].active = false;
                   
                    // dropping it at the center of the drop zones (x/y are drawing)
                    shapes[active_ring].x = drop_coord.x;
                    shapes[active_ring].y = drop_coord.y;

                    // updating row/col location of the ring (row/col for state)
                    shapes[active_ring].m_row = drop_coord.m_row;
                    shapes[active_ring].m_col = drop_coord.m_col;

                    // create and dispatch event for the ring being dropped -> game state should change
                    const ringDrop_event = new CustomEvent("ring_dropped", { detail: shapes[active_ring] });
                    game_state_target.dispatchEvent(ringDrop_event);

                    // logging drop coordinates
                    //console.log(drop_coord);

                    // re-draw everything
                    refresh_draw_state();

                    // play sound
                    sfxr.play(sound);
                };  
            };
        });

    canvas.addEventListener("mouseup", 
        function (evt) {
            //console.log("up");
        });

    canvas.addEventListener("mousemove", 
        function (evt) {
            mousePos = getMousePos(canvas, evt);
            //console.log("move");

            active_ring = check_active_ring();

            // if a ring is active, let's drag it -> refresh everything as you move it
            if (active_ring != "no_ring"){

                shapes[active_ring].x = mousePos.x;
                shapes[active_ring].y = mousePos.y;
                refresh_draw_state();
            };

        });

    // Get the position of the mouse relative to the canvas
    function getMousePos(canvasDom, mouseEvent) {
    var canvasRect = canvasDom.getBoundingClientRect();
    return {
        x: mouseEvent.clientX - canvasRect.left,
        y: mouseEvent.clientY - canvasRect.top
    };
    }


    // Set up touch events 
    // Touch events are mapped to and dispatch mouse events, all events are handled from those!
    canvas.addEventListener("touchstart", 
        function (evt) {
            //mousePos = getTouchPos(canvas, evt); //might be redundant
            let touch = evt.touches[0];
            let mouseEvent = new MouseEvent("mousedown", {
                clientX: touch.clientX,
                clientY: touch.clientY
                });
            
            canvas.dispatchEvent(mouseEvent);
        });

    canvas.addEventListener("touchend", 
        function (evt) {
            let mouseEvent = new MouseEvent("mouseup", {});
            canvas.dispatchEvent(mouseEvent);
        });

    canvas.addEventListener("touchmove", 
        function (evt) {
            let touch = evt.touches[0];
            let mouseEvent = new MouseEvent("mousemove", {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });

    /* NOT SURE IF NEEDED, as we trigger the mouse evt and coordinates are adjusted already once
    // Get the position of a touch relative to the canvas
    function getTouchPos(canvasDom, touchEvent) {
    var canvasRect = canvasDom.getBoundingClientRect();
    return {
        x: touchEvent.touches[0].clientX - canvasRect.left,
        y: touchEvent.touches[0].clientY - canvasRect.top
    };
    }
    */


    // Prevent scrolling when touching the canvas given conflict with touch/drag gestures
    document.body.addEventListener("touchstart", 
        function (evt) {
            if (evt.target == canvas) {
                evt.preventDefault();
            }
        });

    document.body.addEventListener("touchend", 
        function (evt) {
            if (evt.target == canvas) {
                evt.preventDefault();
            }
        });

    document.body.addEventListener("touchmove", 
        function (evt) {
            if (evt.target == canvas) {
                evt.preventDefault();
            }
        });

        

    // server call for checking allowable moves 
    async function server_allowed_moves(state, row, col){

        // https://stackoverflow.com/questions/48708449/promise-pending-why-is-it-still-pending-how-can-i-fix-this
        // https://stackoverflow.com/questions/40385133/retrieve-data-from-a-readablestream-object
        
    
        response = await fetch('http://localhost:1019/api/yinsh/v1/allowed_moves', {
            method: 'POST',
            body: JSON.stringify({
                                    "game_id": 'dummy_game_unique_id', 
                                    "state": state, 
                                    "row": row,
                                    "col": col

                                })
        });

        // note: passing the state could be redundant, only game id should be necessary
        
        // get allowed moves back from the server (array)
        srv_allowed_moves = await response.json(); // note: json() is async and must be awaited, otherwise we print the promise object itself 
        
        // parse and store allowed moves
        let allowed_moves = [];

        if (srv_allowed_moves.length > 0) {
            for (const move of srv_allowed_moves.values()) {
                allowed_moves.push(move.I);
            };
        };
        
        console.log("Allowed moves: ");
        console.log(allowed_moves);

        return allowed_moves;

    };
   

    


</script>
</body>
</html>